<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用腾讯云CDN加速HEXO博客</title>
      <link href="2021/01/08/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91CDN%E5%8A%A0%E9%80%9FHEXO%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/01/08/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91CDN%E5%8A%A0%E9%80%9FHEXO%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>其实就像如何把大象装进冰箱里一样——（把冰箱门打开，把大象装进去，把冰箱门关上），使用CDN加速博客也简单的分为：部署博客，打开CDN，用CDN加速博客。（逃~~）</p><p>咳咳，扯远了。这里讲了如何使用腾讯云CDN加速我的HEXO博客，其他的CDN服务也大同小异，基本都可以参考。</p><h2 id="配置Github-Pages服务"><a href="#配置Github-Pages服务" class="headerlink" title="配置Github Pages服务"></a>配置Github Pages服务</h2><p>首先我们需要有一个HEXO博客，并且已经将它上传到了Github的仓库中，然后在仓库的Settings选项卡中，找到Github Pages选项。这里由于我的仓库名是：<code>lan-mao.github.io</code>这种格式的，所以可以直接使用这个三级域名访问。并且默认开启了HTTPS服务，这里需要注意，如果使用的是七牛云的免费CDN服务是无法加速HTTPS协议的。当然如果有自己域名的也可以直接使用自定义，或者在CNAME文件中修改，不过要注意的是，一个仓库只支持一个域名。使用自定义的域名可以不使用HTTPS协议。</p><p>重点需要注意的是，如果自定义域名，自定义的域名需要在域名的DNS解析服务上添加到Github Pages的解析。并且这个域名不能与你要加速的域名相同，否则会出现循环重定向的问题。</p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/26816496654600.png" alt="Github Pages选项"></p><h2 id="配置CDN服务"><a href="#配置CDN服务" class="headerlink" title="配置CDN服务"></a>配置CDN服务</h2><p>首先需要拥有一个经过备案的域名，这里我使用的是我自己的域名：<a href="https://blog.lan-mao.top/">blog.lan-mao.top</a></p><p>然后开通腾讯云的CDN服务，由于我开通的CDN服务比较早，当时有每月免费的10GB流量数据的优惠，现在已经没了。虽然只有10GB，但是由于我另外的腾讯云对象存储COS也开通的比较早，所以有50GB的免费存储容量。这样我就可以将文章中的图片放到COS中，并且不通过CDN加速。同时我还将大部分的静态资源放到了码云的仓库中，尽管码云的仓库不支持Push后自动更新Page页面，但是使用静态页面来提供一些静态资源还是可以的。（我可真是个小机灵鬼ヽ(ﾟ∀ﾟ*)ﾉ━━━ｩ♪ ）</p><p>在CDN服务中添加域名。如图所示。</p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/26849150159900.png" alt="腾讯云CDN添加域名"></p><ul><li>业务类型：是博客所以选择静态加速</li><li>源站配置：</li><li>源站类型：我们使用的是Github的服务器，所以选<code>自有源</code></li><li>回源协议：看你有没有开通Github Pages的HTTPS协议了</li><li>源站地址：源站地址代表的是你可以通过这个地址访问到资源，要注意源站地址不是上面填写的加速域名</li><li>回源域名：访问源站时用哪个域名，由于我们配置的是Github Pages，仅仅支持一个域名访问。所以只能用对应的那个域名才能不报<code>404</code></li></ul><p>配置好以后大部分的东西默认就行了，其他的选项可以看文档自己鼓捣了。CDN会给一个CDN的域名，是需要将你加速的域名映射到这个CDN域名上的。</p><h2 id="在域名的DNS解析服务中添加到CDN的解析"><a href="#在域名的DNS解析服务中添加到CDN的解析" class="headerlink" title="在域名的DNS解析服务中添加到CDN的解析"></a>在域名的DNS解析服务中添加到CDN的解析</h2><p>我用的域名是阿里云的，具体配置如图：</p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/27632539945900.png" alt="阿里云添加DNS解析"></p><p>需要添加的是一个CNAME记录，值为刚刚给的CDN域名。</p><h3 id="配置HTTPS服务"><a href="#配置HTTPS服务" class="headerlink" title="配置HTTPS服务"></a>配置HTTPS服务</h3><p>如果上面的步骤都做完了，同时也能访问，但是浏览器提示连接不安全。这是因为没有配置域名对应的HTTPS证书，默认的是一个腾讯云的通用证书。我们需要将HTTPS证书部署到CDN中去。</p><ol><li><p>首先需要购买一个SSL证书，我这里使用的是阿里云提供的一个一年免费的SSL证书：<br> <img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/28000177737400.png" alt="阿里云证书申请"></p></li><li><p>申请过程按照提示的步骤进行即可，申请成功后，下载其中的Nginx版本的证书：<br> <img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/28063441854200.png" alt="证书下载"></p></li><li><p>添加证书的公钥和私钥到CDN的HTTPS配置中：<br> <img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/28207841305500.png" alt="证书添加"></p></li><li><p>保存后等待一会就好了。  </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 1/0世界 </category>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写一个词法分析器</title>
      <link href="2020/04/09/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
      <url>2020/04/09/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先声明，文中的一些名称可能不太标准，大部分是我自己的理解。各位看官多多包涵，如果有一些建议可以提出来，我会酌情更改<br>这个词法分析器默认输入的全是 ASCII 码。<br>具体的代码实现使用的语言是Java</p></blockquote><h2 id="分析词法要求"><a href="#分析词法要求" class="headerlink" title="分析词法要求"></a>分析词法要求</h2><p>这个词法分析器有18个令牌。</p><pre><code>⟨letter⟩ → a | b | ... | z | A | B | ... | Z⟨digit⟩ → 0 | 1 | ... | 9⟨id⟩ → ⟨letter⟩ {⟨letter⟩ | ⟨digit⟩}⟨int⟩ → [+|−] {⟨digit⟩}+⟨float⟩ → [+|−] ( {⟨digit⟩}+ "." {⟨digit⟩}  |  "." {⟨digit⟩}+ )⟨floatE⟩ → (⟨int⟩ | ⟨float⟩) (e|E) [+|−] {⟨digit⟩}+⟨floatF⟩ → (⟨int⟩ | ⟨float⟩ | ⟨floatE⟩) ("f" | "F")⟨add⟩ → +⟨sub⟩ → −⟨mul⟩ → *⟨div⟩ → /⟨lt⟩ → &lt;⟨le⟩ → "&lt;="⟨gt⟩ → &gt;⟨ge⟩ → "&gt;="⟨eq⟩ → =⟨LParen⟩ → (⟨RParen⟩ → )⟨LBrace⟩ → {⟨RBrace⟩ → } </code></pre><p>另外还有10个关键字：</p><blockquote><p>if, then, else, or, and, not, pair, first, second, nil </p></blockquote><p>我们需要通过程序实现读入一个文件，分析其中对应的词法状态，并将其输出出来。</p><p>示例：</p><pre><code>输入文本：5+5-51234+1234-1234+ - * / ( ) { }&lt; &gt; &lt;= &gt;= =&lt; = &gt; =[ ]|| &amp;&amp; !,:;输出结果：5   : Int+5   : Int-5   : Int1234   : Int+1234   : Int-1234   : Int+   : Add-   : Sub*   : Mul/   : Div(   : LParen)   : RParen{   : LBrace}   : RBrace&lt;   : Lt&gt;   : Gt&lt;=   : Le&gt;=   : Ge=   : Eq&lt;   : Lt=   : Eq&gt;   : Gt=   : Eq[ : Lexical Error, invalid token] : Lexical Error, invalid token| : Lexical Error, invalid token| : Lexical Error, invalid token&amp; : Lexical Error, invalid token&amp; : Lexical Error, invalid token! : Lexical Error, invalid token, : Lexical Error, invalid token: : Lexical Error, invalid token; : Lexical Error, invalid token</code></pre><pre><code>输入文本：ifthenelseorandnotpairfirstsecondnilitheelsoannopaifirsseconniiffthenaelseporeandqnot+pair?first@second+nil-IfTHENElseoRaNdnoTPAIRfirstHandsecondHandnilnullifthenelsethen316eelseortttCS316andnot#Ppairfir%st$secondn[ilCS316_CS316project1_and_abvc_or输出结果：if   : Keyword_ifthen   : Keyword_thenelse   : Keyword_elseor   : Keyword_orand   : Keyword_andnot   : Keyword_notpair   : Keyword_pairfirst   : Keyword_firstsecond   : Keyword_secondnil   : Keyword_nili   : Idthe   : Idels   : Ido   : Idan   : Idno   : Idpai   : Idfirs   : Idsecon   : Idni   : Idiff   : Idthena   : Idelsep   : Idore   : Idandq   : Idnot   : Keyword_not+   : Addpair   : Keyword_pair? : Lexical Error, invalid tokenfirst   : Keyword_first@ : Lexical Error, invalid tokensecond   : Keyword_second+   : Addnil   : Keyword_nil-   : SubIf   : IdTHEN   : IdElse   : IdoR   : IdaNd   : IdnoT   : IdPAIR   : IdfirstHand   : IdsecondHand   : Idnilnull   : Idifthenelse   : Idthen316   : Ideelse   : Idorttt   : IdCS316and   : Idnot   : Keyword_not# : Lexical Error, invalid tokenPpair   : Idfir   : Id% : Lexical Error, invalid tokenst   : Id$ : Lexical Error, invalid tokensecond   : Keyword_secondn   : Id[ : Lexical Error, invalid tokenil   : IdCS316   : Id_ : Lexical Error, invalid tokenCS316project1   : Id_ : Lexical Error, invalid tokenand   : Keyword_and_ : Lexical Error, invalid tokenabvc   : Id_ : Lexical Error, invalid tokenor   : Keyword_or</code></pre><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><h3 id="存储词法结构"><a href="#存储词法结构" class="headerlink" title="存储词法结构"></a>存储词法结构</h3><p>首先使用<code>枚举类</code>记录所有可能的状态，比如18个令牌，和开始、结束、错误状态，以及一些中间状态：Dot、E、EPlusMinus，和10个关键字。  </p><pre><code class="java">public enum State {    Start,    Error,    End,    Id,    Int,    Float,    FloatE,    FloatF,    Add,    Sub,    Mul,    Div,    Lt,    Le,    Gt,    Ge,    Eq,    LParen,    RParen,    LBrace,    RBrace,    Dot,    E,    EPlusMinus,    Keyword_if,    Keyword_then,    Keyword_else,    Keyword_or,    Keyword_and,    Keyword_not,    Keyword_first,    Keyword_second,    Keyword_nil,    Keyword_pair;}</code></pre><p>我觉得词法分析器中最重要的是：如何实现方便保存词法以及对应的状态，并且可以轻松使用。一开始我用 switch…case 语句，但是这种方法写出来的代码冗长，并且包含了大量的逻辑分析，一旦写错修改起来十分麻烦。后来查询一些资料，改用二维数组存储数据。  </p><p>将二维数组的第一个下标对应每一个状态的位置，第二个下标对应 ASCII 码的128个字符。在Java中枚举类的每一个状态都有对应的位置值。而对应状态的位置值对应的一维数组保存着在此状态下下一个输入字符对应的状态。</p><p>使用了数组存储以后，只需要知道当前状态以及下一个字符，就可以通过下标直接访问对应的下一个状态。</p><pre><code class="java">public static void initNextState() {    for (int i = 0; i &lt;= State.size; i++) {        for (int y = 0; y &lt; 128; y++) {            nextState[i][y] = State.Error;        }    }    for (int i = '0'; i &lt;= '9'; i++) {        nextState[State.Start.ordinal()][i] = State.Int;        nextState[State.Id.ordinal()][i] = State.Id;        nextState[State.Int.ordinal()][i] = State.Int;        nextState[State.Add.ordinal()][i] = State.Int;        nextState[State.Sub.ordinal()][i] = State.Int;        nextState[State.Float.ordinal()][i] = State.Float;        nextState[State.Dot.ordinal()][i] = State.Float;        nextState[State.E.ordinal()][i] = State.FloatE;        nextState[State.FloatE.ordinal()][i] = State.FloatE;        nextState[State.EPlusMinus.ordinal()][i] = State.FloatE;    }    for (int i = 'a'; i &lt;= 'z'; i++) {        nextState[State.Start.ordinal()][i] = State.Id;        nextState[State.Id.ordinal()][i] = State.Id;    }    for (int i = 'A'; i &lt;= 'Z'; i++) {        nextState[State.Start.ordinal()][i] = State.Id;        nextState[State.Id.ordinal()][i] = State.Id;    }    nextState[State.Start.ordinal()]['*'] = State.Mul;    nextState[State.Start.ordinal()]['/'] = State.Div;    nextState[State.Start.ordinal()]['('] = State.LParen;    nextState[State.Start.ordinal()][')'] = State.RParen;    nextState[State.Start.ordinal()]['{'] = State.LBrace;    nextState[State.Start.ordinal()]['}'] = State.RBrace;    nextState[State.Start.ordinal()]['&lt;'] = State.Lt;    nextState[State.Start.ordinal()]['&gt;'] = State.Gt;    nextState[State.Start.ordinal()]['='] = State.Eq;    nextState[State.Start.ordinal()]['+'] = State.Add;    nextState[State.Start.ordinal()]['-'] = State.Sub;    nextState[State.Start.ordinal()]['.'] = State.Dot;    nextState[State.Lt.ordinal()]['='] = State.Le;    nextState[State.Gt.ordinal()]['='] = State.Ge;    nextState[State.Int.ordinal()]['f'] = State.FloatF;    nextState[State.Int.ordinal()]['F'] = State.FloatF;    nextState[State.Float.ordinal()]['f'] = State.FloatF;    nextState[State.Float.ordinal()]['F'] = State.FloatF;    nextState[State.FloatE.ordinal()]['f'] = State.FloatF;    nextState[State.FloatE.ordinal()]['F'] = State.FloatF;    nextState[State.Int.ordinal()]['e'] = State.E;    nextState[State.Int.ordinal()]['E'] = State.E;    nextState[State.Float.ordinal()]['e'] = State.E;    nextState[State.Float.ordinal()]['E'] = State.E;    nextState[State.Add.ordinal()]['.'] = State.Dot;    nextState[State.Sub.ordinal()]['.'] = State.Dot;    nextState[State.Int.ordinal()]['.'] = State.Float;    nextState[State.E.ordinal()]['+'] = State.EPlusMinus;    nextState[State.E.ordinal()]['-'] = State.EPlusMinus;}</code></pre><p>然后使用一个 map 保存关键字：</p><pre><code class="java">public static void initKeywordMap() {    keywordMap.put("if", State.Keyword_if);    keywordMap.put("then", State.Keyword_then);    keywordMap.put("else", State.Keyword_else);    keywordMap.put("or", State.Keyword_or);    keywordMap.put("and", State.Keyword_and);    keywordMap.put("not", State.Keyword_not);    keywordMap.put("pair", State.Keyword_pair);    keywordMap.put("first", State.Keyword_first);    keywordMap.put("second", State.Keyword_second);    keywordMap.put("nil", State.Keyword_nil);}</code></pre><h3 id="核心驱动器实现"><a href="#核心驱动器实现" class="headerlink" title="核心驱动器实现"></a>核心驱动器实现</h3><p>保存好所需要的数据以后，就开始实现将输入的字符分析对应每一个状态。</p><p>首先我们先创建一个IO工具类，以便于方便实现输入输出，以及对输入输出位置的设置。</p><pre><code class="java">public class IO {    private static BufferedReader reader = null;    private static BufferedWriter writer = null;    //用于存储读取到的所有文字    private static StringBuilder text = new StringBuilder();    //记录当前读取到的位置    private static int flag = 0;    public static void setIO(String[] values) {        if (values.length != 0) {            String inPath = values[0];            String outPath = values[1];            try {                reader = new BufferedReader(new FileReader(inPath));                writer = new BufferedWriter(new FileWriter(outPath));            } catch (IOException e) {                e.printStackTrace();            }        } else {            reader = new BufferedReader(new InputStreamReader(System.in));            writer = new BufferedWriter(new OutputStreamWriter(System.out));        }    }    /**     * 获取下一个字符     *     * @return 返回下一个字符，如果到达结尾返回-1     */    public static int getNextChar() {        try {            //当flag处于text最后一位时，flag为text.length-1，此时自增1，flag==text.length说明上一次读取处于结尾            //如果标志位为            if (flag == text.length()){                char[] temp = new char[10];                int length = reader.read(temp);                if (length == -1){                    return -1;                }                text.append(new String(temp, 0, length));            }            return text.charAt(flag++);        } catch (IOException e) {            e.printStackTrace();            return -1;        }    }    /**     * 将指针flag位置前移一位     */    public static void forward() {        if (flag &gt;= 0) {            flag--;        }    }    public static boolean hasNext(){        try {            if (flag &lt; text.length()){                return true;            }else {                char[] temp = new char[10];                int length = reader.read(temp);                if (length == -1){                    return false;                }                text.append(new String(temp, 0, length));                return true;            }        } catch (IOException e) {            e.printStackTrace();            return false;        }    }    /**     * 向输出流中写入字符串     *     * @param value 需要写入的字符串     */    public static void print(String value) {        try {            writer.write(value);            writer.flush();        } catch (IOException e) {            e.printStackTrace();        }    }    /**     * 向输出流中写入字符串并换行     *     * @param value 需要写入的字符串     */    public static void println(String value) {        print(value + '\n');    }    public static void close() {        try {            reader.close();            writer.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>接下来可以实现读取并分析输入文本中的词法分析</p><pre><code class="java">/** * 当前的状态 */public static State state = State.Start;public static void getState(){    state = State.Start;    sb.delete(0,sb.length());    int value = 0;    if (!IO.hasNext()){        state = State.End;        return;    }    while ((value = IO.getNextChar()) != -1){        char charTemp = (char)value;        if (charTemp &gt; 127) {            state = State.Error;            return;        }        State stateTemp = nextState[state.ordinal()][charTemp];        //获取下一个状态，如果是错误，则判断上一个状态是否已经可以结束，可以则输出当前的状态        if (stateTemp == State.Error ||Character.isWhitespace(charTemp)){            if (state.isEnd()){                if (state == State.Id){                    state = keywordCheck(state,sb.toString());                }                if (sb.length() &gt; 0 &amp;&amp; !Character.isWhitespace(charTemp)) {                    //如果状态已经结束，则将标志位前移一位                    IO.forward();                }                break;            }else {                if (state == State.Start &amp;&amp; Character.isWhitespace(charTemp)){                    continue;                }else {                    state = State.Error;                    if (!Character.isWhitespace(charTemp))                        sb.append(charTemp);                }            }            break;        }else {            state = stateTemp;            sb.append(charTemp);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 1/0世界 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅的使用IDEA</title>
      <link href="2020/02/10/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8IDEA/"/>
      <url>2020/02/10/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8IDEA/</url>
      
        <content type="html"><![CDATA[<p>IDEA作为Java界最好用的IDE（不接受反驳，不听不听不听），有大量的选项和插件供我们调教出自己喜欢的样式</p><h2 id="调节配置参数"><a href="#调节配置参数" class="headerlink" title="调节配置参数"></a>调节配置参数</h2><p>配置参数调节主要用到两个文件：<code>idea.properties</code>和<code>idea64.exe.vmoptions</code>。<code>idea.properties</code>文件配置的是IDEA的自身的相关配置，例如IDEA的插件目录、系统文件目录、配置文件目录等等；<code>idea64.exe.vmoptions</code>是IDEA运行的JVM环境配置，例如运行内存等<br>可以直接在IDEA的安装目录的<code>bin</code>文件夹下直接打开这两个文件，但是建议在IDEA的Help菜单中或者在开始界面打开进行配置  </p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9049491214300.png" alt="在开始界面中打开参数文件"></p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9737470318100.png" alt="在Help文件夹中打开参数文件"></p><h3 id="调节JVM虚拟机的运行参数"><a href="#调节JVM虚拟机的运行参数" class="headerlink" title="调节JVM虚拟机的运行参数"></a>调节JVM虚拟机的运行参数</h3><ul><li>-Xms128m，分配堆内存时初始内存。16G内存的机器可尝试设置为 -Xms512m</li><li>-Xmx750m，最大可使用的堆内存。16G内存的机器可尝试设置为 -Xmx2048m</li><li>-XX:ReservedCodeCacheSize=225m，16G内存的机器可尝试设置为-XX:ReservedCodeCacheSize=500m</li></ul><h3 id="调节IDEA的个性化配置"><a href="#调节IDEA的个性化配置" class="headerlink" title="调节IDEA的个性化配置"></a>调节IDEA的个性化配置</h3><ul><li>idea.cycle.buffer.size=1024，该属性主要用于控制控制台输出缓存。有遇到一些项目开启很多输出，控制台很快就被刷满了没办法再自动输出后面内容，这种项目建议增大该值或是直接禁用掉，禁用语句 idea.cycle.buffer.size=disabled。</li><li>idea.max.intellisense.filesize=2500，该属性主要用于提高在编辑大文件时候的代码帮助。IntelliJ IDEA 在编辑大文件的时候还是很容易卡顿的。该属性用于设置类文件的最大大小，如果超过这个大小可能导致类文件无法加载。可以调大一些：idea.max.intellisense.filesize=5000</li><li>idea.system.path=${user.home}/.IntelliJIdea/system，该属性主要用于指向 IntelliJ IDEA 的系统文件目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。如果你的项目很多，则该目录会很大，如果你的 C 盘空间不够的时候，还是建议把该目录转移到其他盘符下。</li><li>idea.config.path=${user.home}/.IntelliJIdea/config，该属性主要用于指向 IntelliJ IDEA 的个性化配置目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。其实这里可以把路径设置到OneDrive网盘的位置，这样就可以自动地备份、同步了。</li></ul><h2 id="设置IDEA的选项"><a href="#设置IDEA的选项" class="headerlink" title="设置IDEA的选项"></a>设置IDEA的选项</h2><p>需要注意，IDEA中的有一些设置在打开项目之后的设置默认是不影响到另一个项目的，如果想要调节全局设置，可以设置在开始界面的Configure菜单的Setting选项</p><h3 id="让IDEA更好看"><a href="#让IDEA更好看" class="headerlink" title="让IDEA更好看"></a>让IDEA更好看</h3><h4 id="设置鼠标悬浮提示"><a href="#设置鼠标悬浮提示" class="headerlink" title="设置鼠标悬浮提示"></a>设置鼠标悬浮提示</h4><p>即当鼠标移动到类或者方法上时，可以提示类或方法信息。</p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9257505521700.png" alt="设置显示鼠标悬浮提示"></p><h4 id="开启行号和方法线"><a href="#开启行号和方法线" class="headerlink" title="开启行号和方法线"></a>开启行号和方法线</h4><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9335581014300.png" alt="开启行号和方法线"></p><h4 id="滑动到最后还可以继续滑"><a href="#滑动到最后还可以继续滑" class="headerlink" title="滑动到最后还可以继续滑"></a>滑动到最后还可以继续滑</h4><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9395317483600.png" alt="设置虚拟空行"></p><h3 id="设置代码换行"><a href="#设置代码换行" class="headerlink" title="设置代码换行"></a>设置代码换行</h3><ol><li><p>根据屏幕宽度换行。这是软换行，并不是真的换行<br><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9456831599800.png" alt="软换行"></p></li><li><p>根据代码长度换行。是真的换行<br><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9502855121300.png" alt="硬换行"></p></li></ol><h3 id="自动导入包"><a href="#自动导入包" class="headerlink" title="自动导入包"></a>自动导入包</h3><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/9654966123400.png" alt="导包设置"></p><p>这里的选项1是在书写代码时自动优化导入的包，比如去掉一些没用到的包。选项2是在书写代码时自动导入包。但对于同名的包，还需要<code>Alt+Enter</code>手动导入。</p><h3 id="代码提示"><a href="#代码提示" class="headerlink" title="代码提示"></a>代码提示</h3><p>Idea的代码提示默认区分大小写，默认为<code>First Letter Only</code>。我们可以取消<code>Match case</code>选项，这样就不区分大小写了。</p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/10180372733100.png" alt="代码提示大小写配置"></p><p>在一些需要写SQL语句的地方，比如MyBatis的映射文件，我们也希望它可以像写代码一样提供表信息等的提示。这可以更改下面的两个地方实现</p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/10283116999800.png" alt="SQL语句的代码提示"></p><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/10356699883400.png" alt="项目与数据库的关联"></p><h2 id="IDEA的编码问题"><a href="#IDEA的编码问题" class="headerlink" title="IDEA的编码问题"></a>IDEA的编码问题</h2><h3 id="IDEA的默认编码和项目编码"><a href="#IDEA的默认编码和项目编码" class="headerlink" title="IDEA的默认编码和项目编码"></a>IDEA的默认编码和项目编码</h3><p>在<code>Editor -&gt; File Encodings</code> 选项卡中</p><ul><li>IDE 的编码默认是 UTF-8，Project Encoding 默认是 GBK，修改为 UTF-8。</li><li>properties设置了专门的编码，建议设为UTF-8，并且勾选Transparent native-to-ascii conversion 选项，该选项主要用于转化ASCII字符，一般都要勾选，不然 Properties 文件中的注释显示的都不会是中文。</li></ul><p><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/10679692070100.png" alt="编码设置"></p><h3 id="Tomcat乱码"><a href="#Tomcat乱码" class="headerlink" title="Tomcat乱码"></a>Tomcat乱码</h3><p>如果你的 Tomcat 控制台输出乱码，可以尝试下在 Tomcat 的 VM 参数上加上：<code>-Dfile.encoding=UTF-8</code></p><h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><ol><li><p>在Windows系统中，因为<code>Ctrl+Space</code>被系统的输入法占用掉了，所以可以更改为<code>Ctrl+,</code><br><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/8306941753400.png" alt="更改`Ctrl + Space`快捷键"></p></li><li><p>启用<code>Ctrl+鼠标滚轮</code>调节字体大小<br><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/10954513501000.png" alt="设置鼠标滚轮"></p></li></ol><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ol><li><p>String Manipulation<br>这个插件可以对字符串进行一些大小写转换等操作，默认的快捷键是<code>Alt+M</code><br><img src="/loading.gif" data-original="http://blog-1258302212.cos.ap-nanjing.myqcloud.com/pasteimageintomarkdown/2021-01-08/7970751971400.png" alt="String Manipulation 操作菜单"></p></li><li><p>Rainbow Brackets<br>将括号变成彩色，分辨一大堆括号可以更有层次感</p></li><li><p>Gitee<br>类似于IDEA中默认有的Github插件，Gitee插件提供了对码云仓库的一些访问</p></li><li><p>PasteImageIntoMarkdown<br>提供在Markdown文件中粘贴图片，并可选择图片的存放地址，如：本地、阿里云、腾讯云、七牛云</p></li><li><p>Solarized Themes<br>是我比较喜欢的背景色为黄色的护眼主题，是全局的主题</p></li><li><p>Chinese (Simplified) Language Pack / 中文语言包<br>JetBrains官方提供的IDEA中文包，绝大部分内容都有中文翻译。虽然我个人还是建议使用英文版，不过英语不太好的同学可以用一下。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://youmeek.gitbooks.io/intellij-idea-tutorial/content/">Introduction · IntelliJ-IDEA-Tutorial</a></li><li><a href="https://www.cnblogs.com/zhangpengshou/p/5366413.html">IntelliJ Idea 常用快捷键列表 - 一路前行 - 博客园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 1/0世界 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建一个Hexo博客</title>
      <link href="2020/01/08/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/01/08/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="如何创建一个Hexo博客"><a href="#如何创建一个Hexo博客" class="headerlink" title="如何创建一个Hexo博客"></a>如何创建一个Hexo博客</h2><p>这个问题其实没有太大价值，因为网络上已经有很多关于此的文章，官网里的文档也写的非常清晰，本着不重复发明轮子的原则，在此不再赘述。</p><h2 id="使用自定义主题"><a href="#使用自定义主题" class="headerlink" title="使用自定义主题"></a>使用自定义主题</h2><p>我使用的是<a href="https://github.com/TriDiamond/hexo-theme-obsidian">Obsidian</a> 主题</p><h2 id="加速你的博客"><a href="#加速你的博客" class="headerlink" title="加速你的博客"></a>加速你的博客</h2><h3 id="加速不经常改动的资源"><a href="#加速不经常改动的资源" class="headerlink" title="加速不经常改动的资源"></a>加速不经常改动的资源</h3><p>如何加速，为了解决这个问题，我尝试了很多的解决方案，比如将博客放到到Coding上，但是发现Coding的IP在香港，在我这里访问更慢；另一个设置CDN加速，我尝试了七牛云和腾讯云两个平台，但不知道因为什么，并没有改善很多。</p><p>后来我发现如果部署到码云平台，它的page页面访问速度很快，但是码云的普通用户不能自定义域名，而且不会自动部署，上传之后必须手动部署才行。但另一方面，Github Pages可以自定义域名，并且还是很多个，支持自动部署。并且我发现，码云仓库的资源是可以直接访问的，而一些静态资源也不需要频繁更改，可以使用手工代替。更重要的是：放在码云上的文件不需要花钱。</p><h3 id="把图片放在云上"><a href="#把图片放在云上" class="headerlink" title="把图片放在云上"></a>把图片放在云上</h3><p>图片就不能放在码云了，否则每次新写文章的时候就要手动部署一次，麻烦得很。不过使用VSCode的插件功能就可以自动上传图片到云端的资源库中。并且可以自动生成链接。用过Typora来写MD文章，虽然他的实时渲染功能十分炫酷，但是在Windows平台上不能用插件，使得我还是选择了VSCode。</p><p>腾讯云图片自动上传插件：<a href="https://marketplace.visualstudio.com/items?itemName=galenye.tencent-cloud-cos-upload-image">tencent-cloud-cos-upload-image - Visual Studio Marketplace</a>，可以使用快捷键上传剪贴板上的图片和本地文件。</p><p>阿里云图床的插件：<a href="https://marketplace.visualstudio.com/items?itemName=vvkee.aliyun-oss-upload-image">aliyun oss upload image - Visual Studio Marketplace</a></p><p>七牛云图床的自动上传插件：<a href="https://marketplace.visualstudio.com/items?itemName=imys.qiniu-upload-image">qiniu-upload-image - Visual Studio Marketplace</a></p><blockquote><p>附一个插件：自动将剪贴板中的链接生成链接标签，并且标题是连接的标题，省好多事情：<a href="https://marketplace.visualstudio.com/items?itemName=kukushi.pasteurl">Paste URL - Visual Studio Marketplace</a></p></blockquote><hr><h2 id="2021-01-08更新"><a href="#2021-01-08更新" class="headerlink" title="2021-01-08更新"></a>2021-01-08更新</h2><p>2020年真的是极其魔幻的一年，我自己在这一年里面可以说是一事无成。不过都过去了，都过去了。</p><p>2021年开年的这几天，我将自己的博客合并到了我的一个算是记录我学习编程的全过程的项目 <a href="https://github.com/lan-mao/ComputerWorld/">ComputerWorld</a> 中，并且将全部的源代码都放在了这个项目的Github仓库和Gitee仓库中，写作的工具也转移到了IDEA中。</p><p>在转移的时候遇到的比较大的难题有两个：Git更新并发布博客源代码和将博客使用CDN加速 </p><h3 id="更新主题并将源代码保存至新仓库"><a href="#更新主题并将源代码保存至新仓库" class="headerlink" title="更新主题并将源代码保存至新仓库"></a>更新主题并将源代码保存至新仓库</h3><p>一开始的想法是将主题的代码与作者的代码进行本地的比较，然后将主题文件夹中的文件全部上传至Github中，但是上传之后发现上传的并不是真正的代码，而是一个仓库地址和对应的版本号，代码本身并不在这个仓库中。后来经过查询发现原来这是Git的功能：<code>子模块</code>，是专门用来加载其他远程仓库的代码的。但是这个功能并不能解决我的问题：我想将代码发布到同一个仓库中，但同时也能保留主题本身在原仓库中的分支进度，这需要我将.git文件夹一并添加到git仓库中，但这样仓库就会变得比较大，也不符合精简的原则。因此在摸索了一段时间的子模块功能后，我放弃了这种方式。</p><p>我最终采取的方式是：</p><ol><li><p>将主题文件夹删除git仓库</p></li><li><p>将原作者的主题仓库作为<a href="https://github.com/lan-mao/ComputerWorld/">ComputerWorld</a> 项目的子模块，加载到博客的themes文件夹下面，并保持与最新的主题文件同步</p></li><li><p>通过IDEA的文件对比功能比较两个文件夹中的差异，并且修改需要修改的内容（偷偷插一句：IDEA的对比功能是真的很强大）</p></li></ol><p>通过这样折中的方式，我保持了主题代码可以与作者的代码同步更新，同时也将主题的源代码保存到了仓库中，而仓库也并没有变得太大。算是完美؏؏☝ᖗ乛◡乛ᖘ☝؏؏</p><h3 id="使用CDN加速博客"><a href="#使用CDN加速博客" class="headerlink" title="使用CDN加速博客"></a>使用CDN加速博客</h3><p>由于以前并没有什么加速的实际操作，所以一开始算是一窍不通的。中间走了很多岔路，并且网上有关CDN+Hexo的博文写的很多都含糊不清，所以这个事情我专门写了新的博客，来记录我遇到的坑。</p><p>博客的传送门在这里 <span class="github-emoji"><span>👉</span><img src="/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://blog.lan-mao.top/2021/01/08/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91CDN%E5%8A%A0%E9%80%9FHEXO%E5%8D%9A%E5%AE%A2/">使用腾讯云CDN加速HEXO博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 1/0世界 </category>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>优雅的使用IDEA</title>
      <link href="/2020/02/10/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8IDEA/"/>
      <url>/2020/02/10/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8IDEA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized的不同效果实验</title>
      <link href="/2020/02/10/synchronized%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%88%E6%9E%9C%E5%AE%9E%E9%AA%8C/"/>
      <url>/2020/02/10/synchronized%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%88%E6%9E%9C%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>示例：synchronized方法。锁住的是this。多个线程同时使用一个对象，这个对象里面若有线程执行了这个对象的同步方法，此时其他线程不能使用该同步方法以及其他的同步方法，但是可以使用普通方法。<br>public class TestSyn02 {<br>    public static void main(String[] args) {<br>        Test01 test = new Test01();<br>        new Thread(test, “1”).start();<br>        new Thread(test, “2”).start();<br>        new Thread(test, “3”).start();<br>    }<br>}<br>class Test01 implements Runnable{<br>    static int num = 0;<br>    public synchronized void synFaction1(){<br>        for (int i = 0; i &lt; 10; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“1” + “—–&gt;” +Thread.currentThread().getName() +”—–&gt;” + i);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized void synFaction2(){<br>        for (int i = 0; i &lt; 10; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“2” + “—–&gt;” +Thread.currentThread().getName() +”—–&gt;” + i);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public void synFaction3(){<br>        for (int i = 0; i &lt; 10; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“3” + “—–&gt;” +Thread.currentThread().getName() +”—–&gt;” + i);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    @Override<br>    public void run() {<br>        switch (num){<br>            case 0:{ num++; synFaction1(); break;}<br>            case 1:{ num++; synFaction2(); break;}<br>            case 2:synFaction3();<br>        }<br>    }<br>}<br>运行的结果：<br>3—–&gt;3—–&gt;0<br>1—–&gt;1—–&gt;0<br>1—–&gt;1—–&gt;1<br>3—–&gt;3—–&gt;1<br>3—–&gt;3—–&gt;2<br>1—–&gt;1—–&gt;2<br>2—–&gt;2—–&gt;0<br>2—–&gt;2—–&gt;1<br>2—–&gt;2—–&gt;2<br>    1. 如果给静态方法加synchronized，那么同步锁加在了类上，类中其他加了同步锁的静态方法都不能用，但是未加同步锁的静态方法和所有的实例方法可以使用。也就是说，静态方法的同步锁和实例方法的同步锁不是同一个锁，互不干涉。<br>public class TestSyn03 {<br>    public static void main(String[] args) {<br>        Test02 test = new Test02();<br>        Test02 test2 = new Test02();<br>        new Thread(test,”1”).start();<br>        new Thread(test2,”2”).start();<br>        new Thread(test,”3”).start();<br>        new Thread(test,”4”).start();<br>        new Thread(test,”5”).start();<br>    }<br>}<br>class Test02 implements Runnable{<br>    public synchronized static void synFaction1(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“同步——第一个对象静态同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized static void synFaction2(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“同步——第二个对象静态同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public static void synFaction3(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“非同步——静态非同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized  void synFaction4(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“同步——实例同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized  void synFaction5(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“非同步——实例非同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    @Override<br>    public void run() {<br>        switch (Thread.currentThread().getName()){<br>            case “1”:synFaction1(); break;<br>            case “2”:synFaction2(); break;<br>            case “3”:synFaction3(); break;<br>            case “4”:synFaction4(); break;<br>            case “5”:synFaction5(); break;<br>        }<br>    }<br>}<br>显示结果：<br>同步——第二个对象静态同步方法<br>非同步——静态非同步方法<br>非同步——实例非同步方法<br>非同步——实例非同步方法<br>同步——第二个对象静态同步方法<br>非同步——静态非同步方法<br>非同步——实例非同步方法<br>非同步——静态非同步方法<br>同步——第二个对象静态同步方法<br>同步——实例同步方法<br>同步——第一个对象静态同步方法<br>同步——第一个对象静态同步方法<br>同步——实例同步方法<br>同步——实例同步方法<br>同步——第一个对象静态同步方法<br>    3. 使用synchronized方法块，锁住this<br>    如示例中，在run方法中用同步块锁住this，在main线程直接调用test1的testSyn1()方法和线程1中通过run()方法调用test1的testSyn1()方法，此时两者交替输出，似乎this没有被锁住。但当我们同时调用test2的run方法时，一个运行完了，另一个才开始运行。<br>    这是因为main线程在调用test1.testSyn1()时，没有进行锁的判断，所以可以直接运行。而调用run()方法时，因为run方法里有同步锁，需要先判断这个对象是否被锁住，因此会变成阻塞<br>public class TestSyn04 {<br>    public static void main(String[] args) {<br>        Test03 test1 = new Test03();<br>        test1.name = “test”;<br>        Test03 test2 = new Test03();<br>        test2.name = “test2”;<br>        new Thread(test1, “线程1”).start();<br>        for (int i = 0; i &lt; 5; i++) {<br>            test1.testSyn1();<br>            try {<br>                Thread.sleep(100);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>        new Thread(test2, “线程2”).start();<br>        test2.run();<br>    }<br>}<br>class Test03 implements Runnable{<br>    String name;<br>    public void testSyn1(){<br>        System.out.println(Thread.currentThread().getName()+”\t实例” +name);<br>    }<br>    @Override<br>    public void run() {<br>        synchronized (this){<br>            for (int i = 0; i &lt; 5; i++) {<br>                testSyn1();<br>                try {<br>                    Thread.sleep(100);<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }<br>    }<br>}<br>运行结果：<br>    线程1    实例test<br>    main    实例test<br>    线程1    实例test<br>    main    实例test<br>    main    实例test<br>    线程1    实例test<br>    main    实例test2<br>    main    实例test2<br>    main    实例test2<br>    线程2    实例test2<br>    线程2    实例test2<br>    线程2    实例test2</p><pre><code>4. 使用synchronized方法块锁住类、锁住对象，省略5. 同步方法和同步块同时使用</code></pre><p>public class TestSyn05 {<br>    public static void main(String[] args) {<br>        Test04 test = new Test04();<br>        new Thread(test).start();<br>        test.testSyn1();<br>    }<br>}<br>class Test04 implements Runnable{<br>    public synchronized void testSyn1(){<br>        for (int i = 0; i &lt; 5; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(Thread.currentThread().getName());<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    @Override<br>    public void run() {<br>        synchronized (this){<br>            for (int i = 0; i &lt; 5; i++) {<br>                try {<br>                    Thread.sleep(100);<br>                    System.out.println(Thread.currentThread().getName());<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }<br>    }<br>}<br>结果：<br>main<br>main<br>main<br>Thread-0<br>Thread-0<br>Thread-0<br>这个例子里，同步方法和同步块分别在两个线程里调用，而同步块锁住的是this。我们发现两者发生了互斥的结果，这反应了同步方法其实锁住了this，即当前调用的对象。<br>同理，对类的同步锁也是如此，即同步静态方法其实锁住了这个类。<br>通过上面的分析，我们可以分析出以下的同步过程：<br>同步实例方法就是锁住this的同步块，而同步静态方法就是锁住类.class的同步块，但同时，类与这个类的对象直接不是一个同步锁，两者互不影响。<br>而普通方法，或者没有判断锁的代码依然可以调用被锁住的类，因为运行这些代码的时候，没有经过判断这个类或者对象是否被锁住，形不成阻塞，所以依旧可以使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建一个Hexo博客</title>
      <link href="/2020/01/08/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/01/08/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="如何创建一个Hexo博客"><a href="#如何创建一个Hexo博客" class="headerlink" title="如何创建一个Hexo博客"></a>如何创建一个Hexo博客</h2><p>这个问题其实没有太大价值，因为网络上已经有很多关于此的文章，官网里的文档也写的非常清晰，本着不重复发明轮子的原则，在此不再赘述。</p><h2 id="使用自定义主题"><a href="#使用自定义主题" class="headerlink" title="使用自定义主题"></a>使用自定义主题</h2><p>我使用的是<a href="https://github.com/TriDiamond/hexo-theme-obsidian" target="_blank" rel="noopener">Obsidian</a>主题，至少在我现在看来主题还是挺好看的，配色、样式挺有科技感。移动端适配的也不错，并且作者看起来也还在更新。问题就是Bug挺多，我修改了一些问题，并且将它放在了我的<a href="https://github.com/lan-mao/hexo-theme-obsidian" target="_blank" rel="noopener">Github仓库</a>中，并且在作者更新了版本后尽量也更新。</p><h2 id="加速你的博客"><a href="#加速你的博客" class="headerlink" title="加速你的博客"></a>加速你的博客</h2><h3 id="加速不经常改动的资源"><a href="#加速不经常改动的资源" class="headerlink" title="加速不经常改动的资源"></a>加速不经常改动的资源</h3><p>如何加速，为了解决这个问题，我尝试了很多的解决方案，比如将博客放到到Coding上，但是发现Coding的IP在香港，在我这里访问更慢；另一个设置CDN加速，我尝试了七牛云和腾讯云两个平台，但不知道因为什么，并没有改善很多。</p><p>后来我发现如果部署到码云平台，它的page页面访问速度很快，但是码云的普通用户不能自定义域名，而且不会自动部署，上传之后必须手动部署才行。但另一方面，Github Pages可以自定义域名，并且还是很多个，支持自动部署。并且我发现，码云仓库的资源是可以直接访问的，而一些静态资源也不需要频繁更改，可以使用手工代替。更重要的是：放在码云上的文件不需要花钱。</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200121105239_5d40b446b228b3950995bb6660d4f9c6.gif" alt=""></p><h3 id="把图片放在云上"><a href="#把图片放在云上" class="headerlink" title="把图片放在云上"></a>把图片放在云上</h3><p>图片就不能放在码云了，否则每次新写文章的时候就要手动部署一次，麻烦得很。不过使用VSCode的插件功能就可以自动上传图片到云端的资源库中。并且可以自动生成链接。用过Typora来写MD文章，虽然他的实时渲染功能十分炫酷，但是在Windows平台上不能用插件，使得我还是选择了VSCode。</p><p>腾讯云图片自动上传插件：<a href="https://marketplace.visualstudio.com/items?itemName=galenye.tencent-cloud-cos-upload-image" target="_blank" rel="noopener">tencent-cloud-cos-upload-image - Visual Studio Marketplace</a>，可以使用快捷键上传剪贴板上的图片和本地文件。</p><p>阿里云图床的插件：<a href="https://marketplace.visualstudio.com/items?itemName=vvkee.aliyun-oss-upload-image" target="_blank" rel="noopener">aliyun oss upload image - Visual Studio Marketplace</a></p><p>七牛云图床的自动上传插件：<a href="https://marketplace.visualstudio.com/items?itemName=imys.qiniu-upload-image" target="_blank" rel="noopener">qiniu-upload-image - Visual Studio Marketplace</a></p><blockquote><p>附一个插件：自动将剪贴板中的链接生成链接标签，并且标题是连接的标题，省好多事情：<a href="https://marketplace.visualstudio.com/items?itemName=kukushi.pasteurl" target="_blank" rel="noopener">Paste URL - Visual Studio Marketplace</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 1/0世界 </category>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>优雅的使用IDEA</title>
      <link href="/2020/02/10/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8IDEA/"/>
      <url>/2020/02/10/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8IDEA/</url>
      
        <content type="html"><![CDATA[<p>IDEA作为Java界最好用的IDE，有大量的选项和插件供我们调教出自己喜欢的样式</p><h2 id="调节配置参数"><a href="#调节配置参数" class="headerlink" title="调节配置参数"></a>调节配置参数</h2><p>需要注意的是，配置这两个文件要在IDEA的Help菜单中打开，或者在开始界面打开  </p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307105500_7dda15f5c58aadd99071aa7d2e411cd4.png" alt="20200307105500_7dda15f5c58aadd99071aa7d2e411cd4.png"></p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307105624_43b0bb26d8c8e9fbcdffc6983b31211e.png" alt="20200307105624_43b0bb26d8c8e9fbcdffc6983b31211e.png"></p><h3 id="调节JVM虚拟机的运行参数"><a href="#调节JVM虚拟机的运行参数" class="headerlink" title="调节JVM虚拟机的运行参数"></a>调节JVM虚拟机的运行参数</h3><ul><li>-Xms128m，分配堆内存时初始内存。16G内存的机器可尝试设置为 -Xms512m</li><li>-Xmx750m，最大可使用的堆内存。16G内存的机器可尝试设置为 -Xmx2048m</li><li>-XX:ReservedCodeCacheSize=225m，16G内存的机器可尝试设置为-XX:ReservedCodeCacheSize=500m</li></ul><h3 id="调节IDEA的个性化配置"><a href="#调节IDEA的个性化配置" class="headerlink" title="调节IDEA的个性化配置"></a>调节IDEA的个性化配置</h3><ul><li>idea.cycle.buffer.size=1024，该属性主要用于控制控制台输出缓存。有遇到一些项目开启很多输出，控制台很快就被刷满了没办法再自动输出后面内容，这种项目建议增大该值或是直接禁用掉，禁用语句 idea.cycle.buffer.size=disabled。</li><li>idea.max.intellisense.filesize=2500，该属性主要用于提高在编辑大文件时候的代码帮助。IntelliJ IDEA 在编辑大文件的时候还是很容易卡顿的。该属性用于设置类文件的最大大小，如果超过这个大小可能导致类文件无法加载。可以调大一些：idea.max.intellisense.filesize=5000</li><li>idea.system.path=${user.home}/.IntelliJIdea/system，该属性主要用于指向 IntelliJ IDEA 的系统文件目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。如果你的项目很多，则该目录会很大，如果你的 C 盘空间不够的时候，还是建议把该目录转移到其他盘符下。</li><li>idea.config.path=${user.home}/.IntelliJIdea/config，该属性主要用于指向 IntelliJ IDEA 的个性化配置目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。其实这里可以把路径设置到OneDrive网盘的位置，这样就可以自动地备份、同步了。</li></ul><h2 id="设置IDEA的选项"><a href="#设置IDEA的选项" class="headerlink" title="设置IDEA的选项"></a>设置IDEA的选项</h2><p>需要注意，IDEA中的有一些设置在打开项目之后的设置默认是不影响到另一个项目的，如果想要调节全局设置，可以设置在开始界面的Configure菜单的Setting选项</p><h3 id="让IDEA更好看"><a href="#让IDEA更好看" class="headerlink" title="让IDEA更好看"></a>让IDEA更好看</h3><h4 id="设置鼠标悬浮提示"><a href="#设置鼠标悬浮提示" class="headerlink" title="设置鼠标悬浮提示"></a>设置鼠标悬浮提示</h4><p>即当鼠标移动到类或者方法上时，可以提示类或方法信息。</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307110545_2f784c38cec6cc19d21909ea94a6e7e5.png" alt="20200307110545_2f784c38cec6cc19d21909ea94a6e7e5.png"></p><h4 id="开启行号和方法线"><a href="#开启行号和方法线" class="headerlink" title="开启行号和方法线"></a>开启行号和方法线</h4><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307111027_3579644aa23d08eea3629396afce7205.png" alt="20200307111027_3579644aa23d08eea3629396afce7205.png"></p><h4 id="滑动到最后还可以继续滑"><a href="#滑动到最后还可以继续滑" class="headerlink" title="滑动到最后还可以继续滑"></a>滑动到最后还可以继续滑</h4><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307111107_60f8a435236b6c6410e8774964193996.png" alt="20200307111107_60f8a435236b6c6410e8774964193996.png"></p><h3 id="设置代码换行"><a href="#设置代码换行" class="headerlink" title="设置代码换行"></a>设置代码换行</h3><ol><li>根据屏幕宽度换行。这是软换行，并不是真的换行<br> <img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307111310_daa103a9ea626cbfa1ab47600914c188.png" alt="20200307111310_daa103a9ea626cbfa1ab47600914c188.png"></li><li>根据代码长度换行。是真的换行<br><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307111422_b13ea302b8b828ecf8aa0a53e6c20f62.png" alt="20200307111422_b13ea302b8b828ecf8aa0a53e6c20f62.png"></li></ol><h3 id="取消保存自动删除行尾空格"><a href="#取消保存自动删除行尾空格" class="headerlink" title="取消保存自动删除行尾空格"></a>取消保存自动删除行尾空格</h3><p>IDEA在默认情况下会自动删除行尾的空格，这样可能造成在git上即使我们没有修改代码，但还是提示有修改。</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307111701_342873369383e5541921695a4f6c5154.png" alt="20200307111701_342873369383e5541921695a4f6c5154.png"></p><h3 id="自动导入包"><a href="#自动导入包" class="headerlink" title="自动导入包"></a>自动导入包</h3><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307111822_fb855f18f38147656c13893460b29058.png" alt="20200307111822_fb855f18f38147656c13893460b29058.png">  </p><p>这里的选项1代表在书写代码时自动优化导入的包，比如去掉一些没用的包。选项2代表在书写代码时自动导入包。但对于同名的包，还需要<code>Alt+Enter</code>手动导入。</p><h3 id="代码提示"><a href="#代码提示" class="headerlink" title="代码提示"></a>代码提示</h3><p>Idea的代码提示默认区分大小写，默认为<code>First Letter Only</code>。我们可以取消<code>Match case</code>选项，这样就不区分大小写了。</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307111953_91280125911225f4708be29e98e08160.png" alt="20200307111953_91280125911225f4708be29e98e08160.png"></p><p>在一些需要写SQL语句的地方，比如MyBatis的映射文件，我们也希望它可以像写代码一样提供表信息等的提示。这可以更改下面的两个地方实现</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307112147_b6d2708fc8dc0d3f7b0c20ce6721adb2.png" alt="20200307112147_b6d2708fc8dc0d3f7b0c20ce6721adb2.png"></p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307112155_e9a972bc436aa491f329c1f1113c13fa.png" alt="20200307112155_e9a972bc436aa491f329c1f1113c13fa.png"></p><h2 id="IDEA的编码问题"><a href="#IDEA的编码问题" class="headerlink" title="IDEA的编码问题"></a>IDEA的编码问题</h2><h3 id="IDEA的默认编码和项目编码"><a href="#IDEA的默认编码和项目编码" class="headerlink" title="IDEA的默认编码和项目编码"></a>IDEA的默认编码和项目编码</h3><p>在<code>Editor -&gt; File Encodings</code> 选项卡中</p><ul><li>IDE 的编码默认是 UTF-8，Project Encoding 默认是 GBK，修改为 UTF-8。</li><li>properties设置了专门的编码，建议设为UTF-8，并且勾选Transparent native-to-ascii conversion 选项，该选项主要用于转化ASCII字符，一般都要勾选，不然 Properties 文件中的注释显示的都不会是中文。</li></ul><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307112817_f321b52d0f616715dd63b4475489b84c.png" alt="20200307112817_f321b52d0f616715dd63b4475489b84c.png"></p><h3 id="设置文件的字体"><a href="#设置文件的字体" class="headerlink" title="设置文件的字体"></a>设置文件的字体</h3><p>字体中必须包含中文，否则依然可能造成乱码、字符显示不出等问题</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307112935_5416d21d86f606349c46a6d92eb99836.png" alt="20200307112935_5416d21d86f606349c46a6d92eb99836.png"></p><p>如图选项<code>Show only monospaced fonts</code>为只显示等宽字体，个人喜欢使用<code>Microsoft Yahei Mono</code>字体，包含中英文，样式和<code>Consola</code>字体类似。</p><h3 id="设置控制台的字体"><a href="#设置控制台的字体" class="headerlink" title="设置控制台的字体"></a>设置控制台的字体</h3><p>如果控制台字体出现乱码则需要修改该选项：</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307113039_fe56bb7bbba5a143eb6fb9efd6811bc3.png" alt="20200307113039_fe56bb7bbba5a143eb6fb9efd6811bc3.png"></p><h3 id="Tomcat乱码"><a href="#Tomcat乱码" class="headerlink" title="Tomcat乱码"></a>Tomcat乱码</h3><p>如果你的 Tomcat 控制台输出乱码，并且你已经保证了本文上面的控制台字体设置的字体包含中文，那你还可以尝试下在 Tomcat 的 VM 参数上加上：<code>-Dfile.encoding=UTF-8</code></p><h2 id="使用待办事项"><a href="#使用待办事项" class="headerlink" title="使用待办事项"></a>使用待办事项</h2><p>我们可以使用TODO语句创建一个代办事项。待办事项的在下方的TODO窗口中可以看到。</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307113236_e3d5eb1883730bef65b54271618bb39d.png" alt="20200307113236_e3d5eb1883730bef65b54271618bb39d.png"></p><p>如图所示，可以创建单行注释，也可以创建多行注释。使用多行注释的时候需要注意，第二行必须有缩进，不然就会只是当做普通注释</p><h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><ol><li><p>在Windows系统中，因为<code>Ctrl+Space</code>被系统的输入法占用掉了，所以可以更改为<code>Ctrl+,</code></p><p> <img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307113648_9d6cb1c580e51c2f3c1fd9f9de950481.png" alt="20200307113648_9d6cb1c580e51c2f3c1fd9f9de950481.png"></p></li><li><p>启用<code>Ctrl+鼠标滚轮</code>调节字体大小<br><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307113956_cb98bde763ec7ce8eafc7627e16e11da.png" alt="20200307113956_cb98bde763ec7ce8eafc7627e16e11da.png"></p></li></ol><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ol><li>String Manipulation<br>这个插件可以对字符串进行一些大小写转换等操作，默认的快捷键是<code>Alt+M</code><br><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200307114359_6c474f3f0f6e2c207e166b36e055f4ff.png" alt="20200307114359_6c474f3f0f6e2c207e166b36e055f4ff.png"></li><li>Rainbow Brackets<br>将括号变成彩色，分辨一大堆括号可以更有层次感</li><li>Gitee<br>类似于IDEA中默认有的Github插件，Gitee插件提供了对码云仓库的一些访问</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://youmeek.gitbooks.io/intellij-idea-tutorial/content/" target="_blank" rel="noopener">Introduction · IntelliJ-IDEA-Tutorial</a></li><li><a href="https://www.cnblogs.com/zhangpengshou/p/5366413.html" target="_blank" rel="noopener">IntelliJ Idea 常用快捷键列表 - 一路前行 - 博客园</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized的不同效果实验</title>
      <link href="/2020/02/10/synchronized%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%88%E6%9E%9C%E5%AE%9E%E9%AA%8C/"/>
      <url>/2020/02/10/synchronized%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%88%E6%9E%9C%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>示例：synchronized方法。锁住的是this。多个线程同时使用一个对象，这个对象里面若有线程执行了这个对象的同步方法，此时其他线程不能使用该同步方法以及其他的同步方法，但是可以使用普通方法。<br>public class TestSyn02 {<br>    public static void main(String[] args) {<br>        Test01 test = new Test01();<br>        new Thread(test, “1”).start();<br>        new Thread(test, “2”).start();<br>        new Thread(test, “3”).start();<br>    }<br>}<br>class Test01 implements Runnable{<br>    static int num = 0;<br>    public synchronized void synFaction1(){<br>        for (int i = 0; i &lt; 10; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“1” + “—–&gt;” +Thread.currentThread().getName() +”—–&gt;” + i);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized void synFaction2(){<br>        for (int i = 0; i &lt; 10; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“2” + “—–&gt;” +Thread.currentThread().getName() +”—–&gt;” + i);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public void synFaction3(){<br>        for (int i = 0; i &lt; 10; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“3” + “—–&gt;” +Thread.currentThread().getName() +”—–&gt;” + i);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    @Override<br>    public void run() {<br>        switch (num){<br>            case 0:{ num++; synFaction1(); break;}<br>            case 1:{ num++; synFaction2(); break;}<br>            case 2:synFaction3();<br>        }<br>    }<br>}<br>运行的结果：<br>3—–&gt;3—–&gt;0<br>1—–&gt;1—–&gt;0<br>1—–&gt;1—–&gt;1<br>3—–&gt;3—–&gt;1<br>3—–&gt;3—–&gt;2<br>1—–&gt;1—–&gt;2<br>2—–&gt;2—–&gt;0<br>2—–&gt;2—–&gt;1<br>2—–&gt;2—–&gt;2<br>    1. 如果给静态方法加synchronized，那么同步锁加在了类上，类中其他加了同步锁的静态方法都不能用，但是未加同步锁的静态方法和所有的实例方法可以使用。也就是说，静态方法的同步锁和实例方法的同步锁不是同一个锁，互不干涉。<br>public class TestSyn03 {<br>    public static void main(String[] args) {<br>        Test02 test = new Test02();<br>        Test02 test2 = new Test02();<br>        new Thread(test,”1”).start();<br>        new Thread(test2,”2”).start();<br>        new Thread(test,”3”).start();<br>        new Thread(test,”4”).start();<br>        new Thread(test,”5”).start();<br>    }<br>}<br>class Test02 implements Runnable{<br>    public synchronized static void synFaction1(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“同步——第一个对象静态同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized static void synFaction2(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“同步——第二个对象静态同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public static void synFaction3(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“非同步——静态非同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized  void synFaction4(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“同步——实例同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    public synchronized  void synFaction5(){<br>        for (int i = 0; i &lt; 3; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(“非同步——实例非同步方法”);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    @Override<br>    public void run() {<br>        switch (Thread.currentThread().getName()){<br>            case “1”:synFaction1(); break;<br>            case “2”:synFaction2(); break;<br>            case “3”:synFaction3(); break;<br>            case “4”:synFaction4(); break;<br>            case “5”:synFaction5(); break;<br>        }<br>    }<br>}<br>显示结果：<br>同步——第二个对象静态同步方法<br>非同步——静态非同步方法<br>非同步——实例非同步方法<br>非同步——实例非同步方法<br>同步——第二个对象静态同步方法<br>非同步——静态非同步方法<br>非同步——实例非同步方法<br>非同步——静态非同步方法<br>同步——第二个对象静态同步方法<br>同步——实例同步方法<br>同步——第一个对象静态同步方法<br>同步——第一个对象静态同步方法<br>同步——实例同步方法<br>同步——实例同步方法<br>同步——第一个对象静态同步方法<br>    3. 使用synchronized方法块，锁住this<br>    如示例中，在run方法中用同步块锁住this，在main线程直接调用test1的testSyn1()方法和线程1中通过run()方法调用test1的testSyn1()方法，此时两者交替输出，似乎this没有被锁住。但当我们同时调用test2的run方法时，一个运行完了，另一个才开始运行。<br>    这是因为main线程在调用test1.testSyn1()时，没有进行锁的判断，所以可以直接运行。而调用run()方法时，因为run方法里有同步锁，需要先判断这个对象是否被锁住，因此会变成阻塞<br>public class TestSyn04 {<br>    public static void main(String[] args) {<br>        Test03 test1 = new Test03();<br>        test1.name = “test”;<br>        Test03 test2 = new Test03();<br>        test2.name = “test2”;<br>        new Thread(test1, “线程1”).start();<br>        for (int i = 0; i &lt; 5; i++) {<br>            test1.testSyn1();<br>            try {<br>                Thread.sleep(100);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>        new Thread(test2, “线程2”).start();<br>        test2.run();<br>    }<br>}<br>class Test03 implements Runnable{<br>    String name;<br>    public void testSyn1(){<br>        System.out.println(Thread.currentThread().getName()+”\t实例” +name);<br>    }<br>    @Override<br>    public void run() {<br>        synchronized (this){<br>            for (int i = 0; i &lt; 5; i++) {<br>                testSyn1();<br>                try {<br>                    Thread.sleep(100);<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }<br>    }<br>}<br>运行结果：<br>    线程1    实例test<br>    main    实例test<br>    线程1    实例test<br>    main    实例test<br>    main    实例test<br>    线程1    实例test<br>    main    实例test2<br>    main    实例test2<br>    main    实例test2<br>    线程2    实例test2<br>    线程2    实例test2<br>    线程2    实例test2</p><pre><code>4. 使用synchronized方法块锁住类、锁住对象，省略5. 同步方法和同步块同时使用</code></pre><p>public class TestSyn05 {<br>    public static void main(String[] args) {<br>        Test04 test = new Test04();<br>        new Thread(test).start();<br>        test.testSyn1();<br>    }<br>}<br>class Test04 implements Runnable{<br>    public synchronized void testSyn1(){<br>        for (int i = 0; i &lt; 5; i++) {<br>            try {<br>                Thread.sleep(100);<br>                System.out.println(Thread.currentThread().getName());<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    @Override<br>    public void run() {<br>        synchronized (this){<br>            for (int i = 0; i &lt; 5; i++) {<br>                try {<br>                    Thread.sleep(100);<br>                    System.out.println(Thread.currentThread().getName());<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }<br>    }<br>}<br>结果：<br>main<br>main<br>main<br>Thread-0<br>Thread-0<br>Thread-0<br>这个例子里，同步方法和同步块分别在两个线程里调用，而同步块锁住的是this。我们发现两者发生了互斥的结果，这反应了同步方法其实锁住了this，即当前调用的对象。<br>同理，对类的同步锁也是如此，即同步静态方法其实锁住了这个类。<br>通过上面的分析，我们可以分析出以下的同步过程：<br>同步实例方法就是锁住this的同步块，而同步静态方法就是锁住类.class的同步块，但同时，类与这个类的对象直接不是一个同步锁，两者互不影响。<br>而普通方法，或者没有判断锁的代码依然可以调用被锁住的类，因为运行这些代码的时候，没有经过判断这个类或者对象是否被锁住，形不成阻塞，所以依旧可以使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建一个Hexo博客</title>
      <link href="/2020/01/08/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/01/08/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="如何创建一个Hexo博客"><a href="#如何创建一个Hexo博客" class="headerlink" title="如何创建一个Hexo博客"></a>如何创建一个Hexo博客</h2><p>这个问题其实没有太大价值，因为网络上已经有很多关于此的文章，官网里的文档也写的非常清晰，本着不重复发明轮子的原则，在此不再赘述。</p><h2 id="使用自定义主题"><a href="#使用自定义主题" class="headerlink" title="使用自定义主题"></a>使用自定义主题</h2><p>我使用的是<a href="https://github.com/TriDiamond/hexo-theme-obsidian" target="_blank" rel="noopener">Obsidian</a>主题，至少在我现在看来主题还是挺好看的，配色、样式挺有科技感。移动端适配的也不错，并且作者看起来也还在更新。问题就是Bug挺多，我修改了一些问题，并且将它放在了我的<a href="https://github.com/lan-mao/hexo-theme-obsidian" target="_blank" rel="noopener">Github仓库</a>中，并且在作者更新了版本后尽量也更新。</p><h2 id="加速你的博客"><a href="#加速你的博客" class="headerlink" title="加速你的博客"></a>加速你的博客</h2><h3 id="加速不经常改动的资源"><a href="#加速不经常改动的资源" class="headerlink" title="加速不经常改动的资源"></a>加速不经常改动的资源</h3><p>如何加速，为了解决这个问题，我尝试了很多的解决方案，比如将博客放到到Coding上，但是发现Coding的IP在香港，在我这里访问更慢；另一个设置CDN加速，我尝试了七牛云和腾讯云两个平台，但不知道因为什么，并没有改善很多。</p><p>后来我发现如果部署到码云平台，它的page页面访问速度很快，但是码云的普通用户不能自定义域名，而且不会自动部署，上传之后必须手动部署才行。但另一方面，Github Pages可以自定义域名，并且还是很多个，支持自动部署。并且我发现，码云仓库的资源是可以直接访问的，而一些静态资源也不需要频繁更改，可以使用手工代替。更重要的是：放在码云上的文件不需要花钱。</p><p><img src="https://blog-source-1258302212.cos.ap-beijing.myqcloud.com/20200121105239_5d40b446b228b3950995bb6660d4f9c6.gif" alt=""></p><h3 id="把图片放在云上"><a href="#把图片放在云上" class="headerlink" title="把图片放在云上"></a>把图片放在云上</h3><p>图片就不能放在码云了，否则每次新写文章的时候就要手动部署一次，麻烦得很。不过使用VSCode的插件功能就可以自动上传图片到云端的资源库中。并且可以自动生成链接。用过Typora来写MD文章，虽然他的实时渲染功能十分炫酷，但是在Windows平台上不能用插件，使得我还是选择了VSCode。</p><p>腾讯云图片自动上传插件：<a href="https://marketplace.visualstudio.com/items?itemName=galenye.tencent-cloud-cos-upload-image" target="_blank" rel="noopener">tencent-cloud-cos-upload-image - Visual Studio Marketplace</a>，可以使用快捷键上传剪贴板上的图片和本地文件。</p><p>阿里云图床的插件：<a href="https://marketplace.visualstudio.com/items?itemName=vvkee.aliyun-oss-upload-image" target="_blank" rel="noopener">aliyun oss upload image - Visual Studio Marketplace</a></p><p>七牛云图床的自动上传插件：<a href="https://marketplace.visualstudio.com/items?itemName=imys.qiniu-upload-image" target="_blank" rel="noopener">qiniu-upload-image - Visual Studio Marketplace</a></p><blockquote><p>附一个插件：自动将剪贴板中的链接生成链接标签，并且标题是连接的标题，省好多事情：<a href="https://marketplace.visualstudio.com/items?itemName=kukushi.pasteurl" target="_blank" rel="noopener">Paste URL - Visual Studio Marketplace</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 1/0世界 </category>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
